#include "PlayerActionMove.h"
#include "Game/Actor/Player/Player.h"
#include "Game/Actor/Player/Action/PlayerActionIdle.h"
// Engine
#include "Engine/System/Input/Input.h"

///////////////////////////////////////////////////////////////////////////////////////////////
// ↓ 設定時のみ行う処理
///////////////////////////////////////////////////////////////////////////////////////////////

void PlayerActionMove::Build() {
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ↓ 初期化
///////////////////////////////////////////////////////////////////////////////////////////////

void PlayerActionMove::OnStart() {
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ↓ 更新
///////////////////////////////////////////////////////////////////////////////////////////////

void PlayerActionMove::OnUpdate() {
	Move();
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ↓ 終了
//////////////////////////////////////////////////////////////////////////////////////////////

void PlayerActionMove::OnEnd() {
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ↓ 次に行うアクションの判定
//////////////////////////////////////////////////////////////////////////////////////////////

void PlayerActionMove::CheckNextAction() {	
	/*if (stick_.x == 0.0f && stick_.y == 0.0f) {
		NextAction<PlayerActionIdle>();
	}*/
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ↓ 入力処理
///////////////////////////////////////////////////////////////////////////////////////////////

bool PlayerActionMove::IsInput() {
	stick_ = Input::GetInstance()->GetLeftJoyStick(kDeadZone_);
	if (stick_.x != 0.0f || stick_.y != 0.0f) {
		return true;
	}
	return false;
}

void PlayerActionMove::Move() {
	stick_ = Input::GetInstance()->GetLeftJoyStick(kDeadZone_);

	QuaternionSRT& transform = pOwner_->GetTransform()->GetSRT();
	Vector3 velocity = transform.rotate.Rotate({stick_.x, 0.0f, stick_.y});

	transform.translate += velocity * GameTimer::DeltaTime();

	if (velocity.x != 0.0f || velocity.y != 0.0f) {
		float angle = std::atan2f(velocity.x, velocity.z);
		Quaternion lerpQuaternion = Quaternion::Slerp(transform.rotate, Quaternion::AngleAxis(angle, Vector3::UP()), 0.1f);
		transform.rotate = lerpQuaternion;
	}
}
